"""解説ブロック（Markdown）をまとめた辞書。
Streamlit では st.markdown(EXPLAINS["Q1"]) のように表示可能。
"""

EXPLAINS = {
    "Q1": '''## Q1 解説：クラス変数と在庫消費（基礎）

**学習ポイント**

- クラス変数は「全インスタンスで共有」される在庫の置き場。
- 在庫操作は 一箇所（クラスメソッド）に集約して安全にする。

**考え方**

1. `has()` で「在庫 >= 必要数」を判定
2. 足りなければ例外
3. 足りるなら減算

**正解例（穴埋め）**

```python
# ___1___
cls.stock.get(item, 0) >= qty
# ___2___
raise OutOfStockError(f"在庫不足: {item}")
# ___3___
-=
```

**よくある落とし穴**

- `cls.stock[item]` 直アクセスで KeyError（`get` を使う）。
- 例外を `return False` にすると呼び出し側のバグが潜む（明示的に raise）。

**追加練習**

- `add_stock(item, qty)` を `@classmethod` で実装して補充も一元化。
''',

    "Q2": '''## Q2 解説：スコープ（global / nonlocal）

**学習ポイント**

- `nonlocal` … 直近の外側のローカル変数を書き換える。
- `global` … モジュール変数（ファイル先頭の変数）を指す。

**正解例（穴埋め）**

```python
# ___1___
nonlocal
# ___2___
global
```

**理解チェック**

- `outer()` は `enclosing -> inner` に更新。
- `use_global()` はモジュールの `x` を直接更新（副作用に注意）。

**落とし穴**

- `nonlocal` はトップレベル変数には効かない（外側“関数”が必要）。

**追加練習**

- `nonlocal` と `global` を混在させ、ログ順を観察。
''',

    "Q3": '''## Q3 解説：ラムダ＆高階関数（最安メニュー）

**学習ポイント**

- `min(iterable, key=...)` で「比較指標」を渡す。
- `lambda x: ...` は小さな無名関数を即席で渡す。

**正解例（穴埋め）**

```python
# ___1___
min
# ___2___
lambda
```

**なぜ `min`？**

- 目的が「最安（最小）」なので `sorted`→先頭より `min` が O(n) で簡潔。

**落とし穴**

- `lambda i: i["price"]` の `i` とキー名のタイプミス。
- 日本語キー/英語キー混在に注意。

**追加練習**

- 「一番トッピング数が多い」= `max(items, key=lambda x: len(x["toppings"]))`
''',

    "Q4": '''## Q4 解説：ジェネレータ（順次提供）

**学習ポイント**

- `yield` は「停止位置を覚えた return」。
- `next(g)` で一杯、`for` / `list()` で残り全部。

**正解例（穴埋め）**

```python
# ___1___
yield
```

**動作の流れ**

1. `next(g)` → 最初の `yield` まで実行して値を返す
2. 2回目以降は前回の続きから

**落とし穴**

- `return "..."` を使うとループが終わってしまう（`yield` を使う）。

**追加練習**

- `yield from` でサブジェネレータに委譲してみる。
''',

    "Q5": '''## Q5 解説：クロージャ（替え玉カウンタ）

**学習ポイント**

- 状態を関数に閉じ込めるテクニック。
- 書き換えには `nonlocal` が必須。

**正解例（穴埋め）**

```python
# ___1___
nonlocal
```

**メリット**

- 外部から `count` に直接触れさせず、インクリメントの窓口を限定できる。

**落とし穴**

- `count += step` は再代入なので `nonlocal` がないと UnboundLocalError。

**追加練習**

- `dec()` も作って増減の最小在庫（0）を超えないように制御。
''',

    "Q6": '''## Q6 解説：デコレータ（提供ログ＆失敗を再送出）

**学習ポイント**

- 例外を握りつぶさずに「横取り→ログ→再送出」が正解。
- 複数の関数に同じ前後処理を差し込むのがデコレータの旨味。

**正解例（穴埋め）**

```python
# ___1___
raise
```

**解説**

- `raise`（引数なし）は直前の例外をそのまま再送出する。
- 呼び出し元に失敗を伝えることで上位のリカバリ戦略を成立させる。

**落とし穴**

- `return None` にしてしまう → 失敗が成功に見えてバグの温床。

**追加練習**

- 処理時間が閾値を超えたら Warning を別途出すデコレータを実装。
''',

    "Q7": '''## Q7 解説：@classmethod / @staticmethod（工場と検証）

**学習ポイント**

- 検証は staticmethod（インスタンス/クラスに依存しない）。
- 生成は classmethod（継承先でも動くファクトリ）。

**正解例（穴埋め）**

```python
# ___1___
Ramen.is_valid_base
# ___2___
cls.VALID_BASES
# ___3___
cls
```

**なぜ `cls`？**

- `from_menu` をサブクラスで呼んでも、そのクラスのインスタンスを返すため。

**落とし穴**

- `is_valid_base` を `@classmethod` にして `cls` を要求する必要はない。

**追加練習**

- `from_config(dict)` の別ファクトリを追加（値不足なら例外）。
''',

    "Q8": '''## Q8 解説：オーバーライド＆データ隠蔽（名前マングリング）

**学習ポイント**

- `super()` で親メソッドを呼び出して基本動作を再利用。
- `__secret` は 名前マングリング で `_ClassName__secret` へ変換される（完全非公開ではないが誤アクセス防止）。

**正解例（穴埋め）**

```python
# ___1___
"egg"
# ___2___
super
```

**検証の仕方**

- 直接 `self.__secret_recipe` は AttributeError
- どうしても参照が必要なら `_Shop__secret_recipe`（推奨しない）

**落とし穴**

- `toppings.append("egg")` の原地操作は別参照の副作用になり得るため、
  安全のため `toppings = toppings + ["egg"]` と新リストで返すのは良策。

**追加練習**

- `PremiumShop` に「自動のり」「自動チャーシュー」をトグルで付ける。
''',
}

